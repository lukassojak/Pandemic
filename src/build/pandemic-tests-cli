#!/bin/sh


#   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
#   ┃   DO NOT EDIT THIS FILE   ┃
#   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


# This is a test suite runner. You will find no tests here.
# Look for files named ‹tests-*.sh› instead.


cli_script_path=$(readlink --canonicalize "$0")
cli_script_bin=$(dirname "${cli_script_path}")

_cli_tests_total=0
_cli_tests_ok=0

_cli_can_run() {
	type "$1" >/dev/null 2>&1
}

_cli_hook_run() {
	if ! _cli_can_run "$1"; then
		return 0
	fi

	_cli_msg_debug "Running $1"
	"$@"
}


_cli_msg_dirty=0

_cli_msg_clear() {
	if [ "$_cli_msg_dirty" -eq 1 ]; then
		echo
		_cli_msg_dirty=0
	fi
}

_cli_msg_test() {
	: $((_cli_tests_total += 1))
	_cli_msg_context="$@"
	_cli_msg_dirty=1
	printf "\e[36mtest\e[0m  \e[36m$_cli_msg_context\e[0m\r"
}

_cli_msg_fatal() {
	_cli_msg_clear
	printf "\e[91m****\e[0m  ${_cli_msg_context:-Fatal error}: \e[31m$@\e[0m\n"
	exit 255
}

_cli_msg_suite() {
	if [ "$_cli_tests_total" -gt 0 ]; then
		echo
		echo
	fi

	printf "\e[36m====\e[0m  \e[1m$@\e[0m\n"
	echo
}

_cli_msg_debug() {
	if [ -z "$CLI_DEBUG" ] || [ "$CLI_DEBUG" -eq 0 ]; then
		return
	fi

	_cli_msg_clear
	printf "\e[95m :: \e[0m  \e[35m$@\e[0m\n"
}

_cli_msg_info() {
	_cli_msg_clear
	printf "\e[34m -- \e[0m  $@\n"
}

_cli_msg_warn() {
	_cli_msg_clear
	printf "\e[33mwarn\e[0m  $@\n"
}

_cli_msg_fail() {
	if [ "$_cli_msg_dirty" -eq 1 ]; then
		printf "\e[1;31mfail\e[0m  \e[31m$_cli_msg_context\e[0m\n"
		_cli_msg_dirty=0
		_cli_msg_context=
	fi

	printf "\e[31m -> \e[0m  $@\n"
}

_cli_msg_ok() {
	: $((_cli_tests_ok += 1))
	_cli_msg_dirty=0
	printf "\e[1;32m ok \e[0m  \e[32m$_cli_msg_context${@:+: $@}\e[0m\n"
}

_cli_msg_clear_context() {
	_cli_msg_context=""
}

_cli_run_validate() {
	for file in $@; do
		if [ ! -f "$file" ]; then
			_cli_msg_fatal "File $file does not exist"
		fi
	done
}

_cli_test_store=

cli_mv_or_rm_empty() {
	if [ $(ls -A "$1" | wc -l) -gt 0 ]; then
		mv "$1" "$2"
	else
		rmdir "$1"
	fi
}

_cli_run_cleanup() {
	if [ -n "$_cli_opt_keep" ] && [ "$_cli_opt_keep" -eq 1 ]; then
		cli_workdir="$1"
		cli_stash="$2"

		if [ -z "$_cli_test_store" ]; then
			_cli_test_store=$(mktemp -d "test-$(date +'%Y%m%d-%H%M%S')-XXXXXX" --suffix=".d")
		fi

		base=$(printf "%s/%03d-%s" "$_cli_test_store" "$_cli_tests_total" "$cli_test_name")

		cli_mv_or_rm_empty "$cli_workdir" "$base.wd"
		cli_mv_or_rm_empty "$cli_stash" "$base.run"
	else
		for object in $@; do
			chmod -R "u+rwX" "$object"
			rm -r "$object"
		done
	fi
}

_cli_run_check_exit() {
	actual="$1"
	expected="$2"

	case "$expected" in
	f|fail*)
		expected=-1
		;;
	s|succ*)
		expected=0
		;;
	esac

	if [ "$expected" -lt 0 ] && [ "$actual" -eq 0 ]; then
		_cli_msg_fail "Program exited with $actual but non-zero was expected"
		return 1
	fi

	if [ "$expected" -eq 0 ] && [ "$actual" -ne 0 ]; then
		_cli_msg_fail "Program exited with $actual but 0 was expected"
		return 1
	fi

	if [ "$expected" -gt 0 ] && [ "$actual" -ne "$expected" ]; then
		_cli_msg_fail "Program exited with $actual but $expected was expected"
		return 1
	fi

	return 0
}

cli_run_diff() {
	patch="$cli_stash/$1.diff"

	_cli_msg_debug "[$1] diff actual   $2"
	_cli_msg_debug "[$1]      expected $3"

	if [ ! -f "$3" ]; then
		_cli_msg_debug "[$1] Expected output file does not exist"
	fi

	if ! diff --new-file "$2" "$3" >"$patch"; then
		_cli_msg_fail "Output '$1' differs"

		# Re-run diff again, this time allowing it to use colours
		diff --color=auto -U5 --new-file "$2" "$3"
		return 1
	fi

	return 0
}

cli_run_check_fail() {
	_cli_msg_fail "Output '$kind' did not pass the custom check"
}

_cli_run_check_output() {
	kind="$1"
	actual="$2"
	expected="$3"

	for prefix in suite cli; do
		if ! type "${prefix}_run_check_${kind}" >/dev/null 2>&1; then
			continue
		fi

		if ! "${prefix}_run_check_${kind}" "$actual" "$expected"; then
			if [ "$_cli_msg_dirty" -ne 0 ]; then
				cli_run_check_fail
			fi

			return 1
		fi

		return 0
	done

	if ! cli_run_diff "$@"; then
		return 1
	fi

	return 0
}

cli_env() {
	export "$@"
	echo "export '$@'" >>"$cli_stash/env"
}

_cli_env_restore() {
	if [ -f "$cli_stash/env" ]; then
		. "$cli_stash/env"
	fi
}

_cli_test_usage() {
	_cli_msg_fatal "usage: run [OPTIONS] DESCRIPTION [--] TEST [ARGS...]"
}

_cli_run_test_options() {
	if [ "$#" -lt 2 ]; then
		_cli_test_usage
	fi

	OPTIND=1
	while getopts "e:I:O:E:0:1:2:c:sS" opt; do
		case "$opt" in
		e)
			_exp_exit=$OPTARG
			;;
		0|I)
			_in=$OPTARG
			;;
		1|O)
			_exp_out=$OPTARG
			;;
		2|E)
			_exp_err=$OPTARG
			;;
		c)
			_cmp=$OPTARG
			;;
		s)
			_strict=1
			;;
		S)
			_strict=0
			;;
		*)
			exit 1
			;;
		esac
	done

	_test_shift=$((OPTIND))
	shift $((OPTIND - 1))

	cli_test_desc=$1
	cli_test_name=$2
	shift 2

	# ‹x› here prevents comparing raw ‹--› which would result in
	# ‹[ -- = -- ]›, and POSIX shell does not like this.
	if [ "x$cli_test_name" = "x--" ]; then
		cli_test_name=$1
		: $((_test_shift += 1))
	fi
}

_cli_resolve_data() {
	suffix="$1"
	name="$2"

	if [ -z "$name" ]; then
		echo "${cli_data}/${cli_test_name}.${suffix}"
	elif [ "${name}" = "${name%/}" ]; then
		echo "${cli_data}/${name}"
	else
		echo "${name}"
	fi
}

_cli_run_test_eval() {
	cli_data="${cli_script_bin}/${test_data:-data}"

	_in=$(_cli_resolve_data in "$_in")
	_exp_out=$(_cli_resolve_data out "$_exp_out")
	_exp_err=$(_cli_resolve_data err "$_exp_err")

	if [ ! -f "$_in" ]; then
		_cli_msg_debug "Input $_in not found, using /dev/null"
		_in=/dev/null
	fi

	cli_stash=$(mktemp --directory --tmpdir=${cli_script_bin} stash.XXXXXX.d)

	_prog_out="$cli_stash/stdout"
	_prog_err="$cli_stash/stderr"

	cli_workdir=$(mktemp --directory --tmpdir=${cli_script_bin} runtime.XXXXXX.d)

	_cli_msg_debug "Stash is $cli_stash"
	_cli_msg_debug "Workdir is $cli_workdir"

	trap '_cli_run_cleanup "$cli_workdir" "$cli_stash"' EXIT TERM INT

	(
		_cli_msg_debug "Executing setup functions"
		cd "$cli_workdir"

		_cli_hook_run "tests_setup" "$cli_test_name"
		_cli_hook_run "suite_setup" "$cli_test_name"
		_cli_hook_run "${cli_test_name}_setup"
	)

	_cli_msg_test "#$((_cli_tests_total + 1)): ${cli_test_desc}"

	(
		_cli_msg_debug "Executing test function"

		set +x
		if [ "$_strict" -eq 1 ]; then
			set -e
		fi

		_cli_env_restore
		cd "$cli_workdir"
		"$@" >&4 2>&5
	) <$_in 3>&1 4>$_prog_out 5>$_prog_err

	exit_code=$?
	_cli_msg_debug "Exit code $exit_code"

	(
		_cli_msg_debug "Executing teardown functions"

		_cli_env_restore
		cd "$cli_workdir"
		_cli_hook_run "${cli_test_name}_teardown"
		_cli_hook_run "suite_teardown" "$cli_test_name"
		_cli_hook_run "tests_teardown" "$cli_test_name"
	)

	fails=0
	if ! _cli_run_check_exit $exit_code ${_exp_exit:-0}; then
		: $((fails += 1))
	fi

	if [ -f "$cli_stash/valgrind.log" ] && ! grep -q 'ERROR SUMMARY: 0 errors' "$cli_stash/valgrind.log"; then
		_cli_msg_fail "Valgrind found errors"
		cat "$cli_stash/valgrind.log"
		: $((fails += 1))
	fi

	if ! ${_cmp:-_cli_run_check_output} stdout $_prog_out $_exp_out; then
		: $((fails += 1))
	fi

	if ! ${_cmp:-_cli_run_check_output} stderr $_prog_err $_exp_err; then
		: $((fails += 1))
	fi

	if [ $fails -eq 0 ]; then
		_cli_msg_ok
	else
		echo
	fi

	_cli_msg_clear_context
	_cli_run_cleanup "$cli_workdir" "$cli_stash"
	trap - EXIT TERM INT
}

_cli_run_filter() {
	if [ -z "$_cli_test_name_filter" ]; then
		return 0
	fi

	test "${_cli_test_name_filter#*"::$1::"}" != "${_cli_test_name_filter}"
}

run() {
	_in=
	_exp_exit=
	_exp_out=
	_exp_err=
	_strict=1
	_cmp=

	_cli_run_test_options "$@"

	if ! _cli_run_filter "$cli_test_name"; then
		return
	fi

	shift "$_test_shift"
	_cli_msg_debug "Test $cli_test_name '$cli_test_desc'"
	: $((cli_suite_count += 1))

	if [ "$_cli_cmd_list" = 1 ]; then
		_cli_msg_clear
		printf "  \e[36m%s\e[0m - %s\n" "$cli_test_name" "$cli_test_desc"
		echo   "      ~$ $cli_test_name $@"
		: $((_cli_tests_total += 1))
	else
		_cli_run_test_eval "$@"
	fi
}

_cli_is_testing() {
	test -z "$_cli_cmd_list"
}

_cli_strwrap() {
	if [ $# -lt 1 ]; then
		echo "usage: strzip STRING [STRINGS]…" 2>&1
		return 1
	fi

	if [ $# -eq 1 ]; then
		return
	fi

	delim=$1
	shift 1

	result="${delim}"

	for str in "$@"; do
		result="${result}${str}${delim}"
	done

	echo "$result"
}

cli_usage() {
	cat <<EOF
usage: $0 [OPTIONS] [TESTS…]

Brief summary of options:
  -h    Show help and exit.
  -k    Keep work directories and stash files.
  -l    List tests.
EOF
}

if [ -f "${cli_script_bin}/cli-utils.sh" ]; then
	. "${cli_script_bin}/cli-utils.sh"
fi

while getopts "hkl" opt; do
	case "$opt" in
	k)
		_cli_opt_keep=1
		;;
	l)
		_cli_cmd_list=1
		;;
	h)
		cli_usage
		exit 0
		;;
	*)
		cli_usage >&2
		exit 1
	esac
done

shift $((OPTIND - 1))

_cli_test_name_filter=$(_cli_strwrap "::" "$@")

if _cli_is_testing; then
	_cli_hook_run tests_init
fi

for file in "${cli_script_bin}"/tests-*.sh; do
	_cli_msg_suite "$(basename $file)"

	unset -f suite_setup
	unset -f suite_teardown
	unset -f suite_run_check_stdout
	unset -f suite_run_check_stderr

	cli_suite_count=0
	. "$file"

	if [ "$cli_suite_count" -eq 0 ]; then
		printf "\e[37mNo tests\e[0m\n"
		echo
	fi
done

if ! _cli_is_testing; then
	_cli_msg_suite "Statistics"
	printf "Total $_cli_tests_total tests\n"
	exit 0
fi

if [ "$_cli_tests_total" -eq 0 ]; then
	_cli_msg_fatal "No tests were run"
fi

_cli_msg_suite "Statistics"
if [ "$_cli_tests_ok" -ne "$_cli_tests_total" ]; then
	printf "Overall status: \e[1;31m✗ FAILURE\e[0m\n"
else
	printf "Overall status: \e[1;32m✔ Great Success\e[0m\n"
fi

printf "  Total tests:  %3d\n" $_cli_tests_total;
printf "  Success:      %3d\n" $_cli_tests_ok;
printf "  Failure       %3d\n" $((_cli_tests_total - _cli_tests_ok));

if [ -n "$_cli_test_store" ]; then
	echo
	echo "Test runtime and work directories are stored in $_cli_test_store"
fi

if [ "$_cli_tests_ok" -ne "$_cli_tests_total" ]; then
	exit 1
fi
